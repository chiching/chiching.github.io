"use strict";(self.webpackChunkrspress_doc_template=self.webpackChunkrspress_doc_template||[]).push([["3746"],{1278:function(e,r,n){n.r(r),n.d(r,{default:function(){return a}});var s=n(5893),c=n(65);function i(e){let r=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",ul:"ul",li:"li",code:"code",em:"em"},(0,c.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(r.h1,{id:"certificate",children:["certificate",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#certificate",children:"#"})]}),"\n",(0,s.jsx)(r.p,{children:"openssl 命令：\r\nreq: 生成证书请求文件和自签名证书。用于创建和处理 PKCS#10 格式的证书\r\nx509	： X.509 证书管理，显示证书信息、转换证书格式、签名证书请求及改变证书信任设置。 证书工具\r\nca： 签发证书请求和生成CRL，维护一个已签发证书状态的文本数据库。证书中心\r\nverify：X.509证书验证。证书验证"}),"\n",(0,s.jsxs)(r.h2,{id:"1-创建根证书root-ca",children:["1. 创建根证书（Root CA）",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#1-创建根证书root-ca",children:"#"})]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["1.1 生成私钥（.key）；",(0,s.jsx)(r.code,{children:"openssl genrsa -out ca.key 1024"})]}),"\n",(0,s.jsxs)(r.li,{children:["1.2 生成证书请求文件（.csr），实际上就是把自身一些信息（国家、机构、域名、邮箱等）用第一步的私钥加密。",(0,s.jsx)(r.code,{children:"openssl req -new -key ca.key -out ca.csr"})]}),"\n",(0,s.jsxs)(r.li,{children:["1.3 自签名证书（.crt），用第一步的私钥给第二步的证书请求文件签名，根证书肯定是自签名的，CA 机构给自己发的证书。\r\n",(0,s.jsx)(r.code,{children:"openssl req -x509 -days 3650 -key ca.key -in ca.csr -out ca.crt "}),"\r\n或者\r\n",(0,s.jsx)(r.code,{children:"openssl x509 -req -days 3650 -in ca.csr -signkey ca.key -out ca.crt"}),"\r\n[-x509]: req 中的 [-x509] 表示生成一个自签名的证书，而不是一个证书请求；\r\n[-req]: x509 中的 [-req] 表示 in 后面的输入文件为证书请求文件，默认是证书文件；\r\n[-signkey]: 用于提供自签名时的私钥文件。"]}),"\n"]}),"\n",(0,s.jsxs)(r.h2,{id:"2创建中间证书intermediate-ca用根证书给中间证书签名中间证书再给用户签名提高安全性",children:["2.创建中间证书（Intermediate CA），用根证书给中间证书签名，中间证书再给用户签名，提高安全性。",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#2创建中间证书intermediate-ca用根证书给中间证书签名中间证书再给用户签名提高安全性",children:"#"})]}),"\n",(0,s.jsx)(r.p,{children:"... 略"}),"\n",(0,s.jsxs)(r.h2,{id:"3-创建用户证书用中间证书给用户签名形成--的证书链",children:["3. 创建用户证书，用中间证书给用户签名，形成 ",(0,s.jsx)(r.em,{children:"用户证书–>中间证书–>根证书"})," 的证书链",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#3-创建用户证书用中间证书给用户签名形成--的证书链",children:"#"})]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsxs)(r.p,{children:["3.1 生成私钥（.key），用户自己拥有 ",(0,s.jsx)(r.code,{children:"openssl genrsa -out server.key 1024"})]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsxs)(r.p,{children:["3.2 生成证书请求文件（.csr），由用户的私钥和用户自身的信息（国家、机构、域名、邮箱等）生成。其中用户的公钥和用户的信息是明文保存在证书请求文件中，而用户私钥的作用是对用户公钥及用户自身信息做签名，私钥不包含在证书请求中；",(0,s.jsx)(r.code,{children:"openssl req -new -key server.key -out server.csr"})]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsxs)(r.p,{children:["3.3 中间证书签名（.crt），用中间证书的私钥给用户证书的证书请求文件签名，签名之后意味着中间证书信任用户证书。\r\n",(0,s.jsx)(r.code,{children:"openssl ca -in server.csr -out server.crt -cert ca.crt -keyfile ca.key"}),"\r\n[-cert]，指定 CA 证书；\r\n[-keyfile]，指定私钥。"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"生成服务端证书（根证书给服务端证书签名）\r\n$ openssl ca -days 3650 -md sha256 -in server.csr  -out server.crt -cert ca.crt -keyfile ca.key -policy  policy_anything -config openssl.cnf -extensions v3_req\r\n生成服务端证书（效果等同上一句）\r\n$ openssl x509 -req -sha256 -days 3650 -in server.csr  -CA ca.crt -CAkey ca.key -out server.crt -CAcreateserial   -extfile /usr/lib/ssl/openssl.cnf -extensions v3_req\r\n-- this line works"}),"\n",(0,s.jsx)(r.p,{children:'mkdir ./demoCA/newcerts\r\necho "" > ./demoCA/index.txt\r\necho "01" > ./demoCA/serial'}),"\n",(0,s.jsxs)(r.p,{children:["取消 /etc/pki/tls/openssl.cnf  or  /usr/lib/ssh/openssl.cnf 中 [req] 节点下这句注释 req_extensions= v3_req，如果想使用自定义的配置文件，看 传送门 。\r\n在 [v3_req ] 节点下新增属性 subjectAltName = @alt_names。\r\n新增如下节点，如果没有 DNS 只填写 IP 即可：\r\n[ alt_names ]\r\nDNS.1 = localhost\r\nDNS.1 = ",(0,s.jsx)(r.a,{href:"http://www.abc.com",target:"_blank",rel:"noopener noreferrer",children:"www.abc.com"}),"\r\nIP.1 = 192.168.1.1"]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.a,{href:"https://www.gokuweb.com/operation/d95eae05.html",target:"_blank",rel:"noopener noreferrer",children:"自签名证书 + Nginx 实现 HTTP 升级 HTTPS"})})]})}function t(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}=Object.assign({},(0,c.ah)(),e.components);return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(i,{...e})}):i(e)}let a=t;t.__RSPRESS_PAGE_META={},t.__RSPRESS_PAGE_META["notes%2F01-Cloud%20Computing%2FLinux%2Fcertificate.md"]={toc:[{text:"1. 创建根证书（Root CA）",id:"1-创建根证书root-ca",depth:2},{text:"2.创建中间证书（Intermediate CA），用根证书给中间证书签名，中间证书再给用户签名，提高安全性。",id:"2创建中间证书intermediate-ca用根证书给中间证书签名中间证书再给用户签名提高安全性",depth:2},{text:"3. 创建用户证书，用中间证书给用户签名，形成 *用户证书–>中间证书–>根证书* 的证书链",id:"3-创建用户证书用中间证书给用户签名形成-用户证书中间证书根证书-的证书链",depth:2}],title:"certificate",frontmatter:{}}}}]);